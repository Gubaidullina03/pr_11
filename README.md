# pr_11

## Цели:
• Оптимизация использования базы данных, позволяющая выполнять больше запросов с меньшими ресурсами.
• Внедрение индексного и последовательного сканирования.
• Интерпретировать вывод EXPLAIN ANALYZE.
• Понимать преимущества использования объединений вместо других функций.
• Внедрение триггеров в ответ на определенные события.
• Создавать и использовать функции для создания более сложных и эффективных запросов.
• Выявление длительных запросов и их завершение.

## Методы сканирования базы данных

## Задание 1

## Задача:
Запросить план для чтения и интерпретации информации, возвращаемой планировщиком.
Предположим, что мы имеем дело с базой данных sqlda с записями о клиентах и что компания хочет, чтобы мы внедрили систему для регулярного создания отчетов о
деятельности клиентов в определенном географическом регионе.
Чтобы убедиться, что отчет может быть запущен своевременно, нужна оценка того, сколько времени займет SQL-запрос. Использовать команду EXPLAIN, чтобы узнать,
сколько времени займут запросы отчета.


## Выполнение задания

Практическое задание №11

Задание 1

Запросить план для чтения и интерпретации информации, возвращаемой планировщиком. Предположим, что мы имеем дело с базой данных sqlda с записями о клиентах и что компания хочет, чтобы мы внедрили систему для регулярного создания отчетов о деятельности клиентов в определенном географическом регионе.
Чтобы убедиться, что отчет может быть запущен своевременно, нужна оценка того, сколько времени займет SQL-запрос. Использовать команду EXPLAIN, чтобы узнать,
сколько времени займут запросы отчета.

1. Используем команду EXPLAIN, чтобы вернуть план запроса для выбора всех доступных записей в таблице клиентов
```sql
EXPLAIN SELECT * FROM customers;
```
Получаем результат:


![Screenshot_64](https://github.com/user-attachments/assets/dbfb74d4-1d18-43b2-ae78-5e156f65b989)



Результат запроса нам показывает первый аспект предоставляемого плана — это тип сканирования, выполняемого запросом (sequential scan - последовательное сканирование).
Затем первое измерение, сообщаемое планировщиком — это начальные затраты, т. е. время, затраченное до начала сканирования.
Следующее число в последовательности указывает общую стоимость выполнения запроса, если будут получены все доступные строки. Последняя цифра в плане указывает общее
количество строк, которые доступны для возврата, если план полностью выполнен.


2. Повторим запрос из шага 2 этого упражнения, на этот раз ограничив количество возвращаемых записей до 15.
```sql
EXPLAIN SELECT * FROM customers LIMIT 15;
```
Получаем результат:


![Screenshot_65](https://github.com/user-attachments/assets/484f47aa-8ed1-4583-85c1-07717961f356)



Теперь наш план состоит из двух отдельных шагов, причем нижняя строка плана повторяет показанный ранее.
Верхняя строка плана — это компонент, который ограничивает результат только 15 строками. Процесс Limit — это дополнительная стоимость запроса; однако это весьма
незначительно по сравнению с планом более низкого уровня,
извлекает примерно 26 368 строк за 1790 запросов страниц.

Этап Limit возвращает только 15 строк по цене 0,46
запроса страницы.


3. Создадим план запроса, выбрав все строки, где клиенты живут в пределах широты 30 и 40 градусов.
```sql
EXPLAIN SELECT * FROM customers WHERE latitude > 30 and latitude < 40;
```

Получим результат:


![Screenshot_66](https://github.com/user-attachments/assets/2a17735e-831e-4068-a178-3f3efce79da6)


Теперь используем более сложный запрос для поиска грасных широт между двумя конкретными значениями в столбце latitude. 

Верхняя строка снова повторяет результат первого запроса, который нам показывает тип сканирования, выполняемого запросом (sequential scan - последовательное сканирование) и т.д
Нижняя строка показывает какой фильтр применяется к каждой строке во время сканирования.

## Индексное сканирование

## Задание 2

##
##
##
##

## Вывод
